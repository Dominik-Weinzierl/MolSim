// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from input.xsd.
 */

#ifndef INPUT_H
#define INPUT_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema {
// anyType and anySimpleType.
//

/**
 * @brief C++ type corresponding to the anyType XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::type type;

/**
 * @brief C++ type corresponding to the anySimpleType XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::simple_type<char, type> simple_type;

/**
 * @brief Alias for the anyType type.
 */
typedef ::xsd::cxx::tree::type container;


// 8-bit
//

/**
 * @brief C++ type corresponding to the byte XML Schema
 * built-in type.
 */
typedef signed char byte;

/**
 * @brief C++ type corresponding to the unsignedByte XML Schema
 * built-in type.
 */
typedef unsigned char unsigned_byte;


// 16-bit
//

/**
 * @brief C++ type corresponding to the short XML Schema
 * built-in type.
 */
typedef short short_;

/**
 * @brief C++ type corresponding to the unsignedShort XML Schema
 * built-in type.
 */
typedef unsigned short unsigned_short;


// 32-bit
//

/**
 * @brief C++ type corresponding to the int XML Schema
 * built-in type.
 */
typedef int int_;

/**
 * @brief C++ type corresponding to the unsignedInt XML Schema
 * built-in type.
 */
typedef unsigned int unsigned_int;


// 64-bit
//

/**
 * @brief C++ type corresponding to the long XML Schema
 * built-in type.
 */
typedef long long long_;

/**
 * @brief C++ type corresponding to the unsignedLong XML Schema
 * built-in type.
 */
typedef unsigned long long unsigned_long;


// Supposed to be arbitrary-length integral types.
//

/**
 * @brief C++ type corresponding to the integer XML Schema
 * built-in type.
 */
typedef long long integer;

/**
 * @brief C++ type corresponding to the nonPositiveInteger XML Schema
 * built-in type.
 */
typedef long long non_positive_integer;

/**
 * @brief C++ type corresponding to the nonNegativeInteger XML Schema
 * built-in type.
 */
typedef unsigned long long non_negative_integer;

/**
 * @brief C++ type corresponding to the positiveInteger XML Schema
 * built-in type.
 */
typedef unsigned long long positive_integer;

/**
 * @brief C++ type corresponding to the negativeInteger XML Schema
 * built-in type.
 */
typedef long long negative_integer;


// Boolean.
//

/**
 * @brief C++ type corresponding to the boolean XML Schema
 * built-in type.
 */
typedef bool boolean;


// Floating-point types.
//

/**
 * @brief C++ type corresponding to the float XML Schema
 * built-in type.
 */
typedef float float_;

/**
 * @brief C++ type corresponding to the double XML Schema
 * built-in type.
 */
typedef double double_;

/**
 * @brief C++ type corresponding to the decimal XML Schema
 * built-in type.
 */
typedef double decimal;


// String types.
//

/**
 * @brief C++ type corresponding to the string XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::string<char, simple_type> string;

/**
 * @brief C++ type corresponding to the normalizedString XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::normalized_string<char, string> normalized_string;

/**
 * @brief C++ type corresponding to the token XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::token<char, normalized_string> token;

/**
 * @brief C++ type corresponding to the Name XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::name<char, token> name;

/**
 * @brief C++ type corresponding to the NMTOKEN XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::nmtoken<char, token> nmtoken;

/**
 * @brief C++ type corresponding to the NMTOKENS XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::nmtokens<char, simple_type, nmtoken> nmtokens;

/**
 * @brief C++ type corresponding to the NCName XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::ncname<char, name> ncname;

/**
 * @brief C++ type corresponding to the language XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::language<char, token> language;


// ID/IDREF.
//

/**
 * @brief C++ type corresponding to the ID XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::id<char, ncname> id;

/**
 * @brief C++ type corresponding to the IDREF XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::idref<char, ncname, type> idref;

/**
 * @brief C++ type corresponding to the IDREFS XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::idrefs<char, simple_type, idref> idrefs;


// URI.
//

/**
 * @brief C++ type corresponding to the anyURI XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::uri<char, simple_type> uri;


// Qualified name.
//

/**
 * @brief C++ type corresponding to the QName XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::qname<char, simple_type, uri, ncname> qname;


// Binary.
//

/**
 * @brief Binary buffer type.
 */
typedef ::xsd::cxx::tree::buffer<char> buffer;

/**
 * @brief C++ type corresponding to the base64Binary XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::base64_binary<char, simple_type> base64_binary;

/**
 * @brief C++ type corresponding to the hexBinary XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::hex_binary<char, simple_type> hex_binary;


// Date/time.
//

/**
 * @brief Time zone type.
 */
typedef ::xsd::cxx::tree::time_zone time_zone;

/**
 * @brief C++ type corresponding to the date XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::date<char, simple_type> date;

/**
 * @brief C++ type corresponding to the dateTime XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::date_time<char, simple_type> date_time;

/**
 * @brief C++ type corresponding to the duration XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::duration<char, simple_type> duration;

/**
 * @brief C++ type corresponding to the gDay XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gday<char, simple_type> gday;

/**
 * @brief C++ type corresponding to the gMonth XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gmonth<char, simple_type> gmonth;

/**
 * @brief C++ type corresponding to the gMonthDay XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gmonth_day<char, simple_type> gmonth_day;

/**
 * @brief C++ type corresponding to the gYear XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gyear<char, simple_type> gyear;

/**
 * @brief C++ type corresponding to the gYearMonth XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gyear_month<char, simple_type> gyear_month;

/**
 * @brief C++ type corresponding to the time XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::time<char, simple_type> time;


// Entity.
//

/**
 * @brief C++ type corresponding to the ENTITY XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::entity<char, ncname> entity;

/**
 * @brief C++ type corresponding to the ENTITIES XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::entities<char, simple_type, entity> entities;

/**
 * @brief Content order sequence entry.
 */
typedef ::xsd::cxx::tree::content_order content_order;
// Namespace information and list stream. Used in
// serialization functions.
//
/**
 * @brief Namespace serialization information.
 */
typedef ::xsd::cxx::xml::dom::namespace_info<char> namespace_info;

/**
 * @brief Namespace serialization information map.
 */
typedef ::xsd::cxx::xml::dom::namespace_infomap<char> namespace_infomap;

/**
 * @brief List serialization stream.
 */
typedef ::xsd::cxx::tree::list_stream<char> list_stream;

/**
 * @brief Serialization wrapper for the %double type.
 */
typedef ::xsd::cxx::tree::as_double<double_> as_double;

/**
 * @brief Serialization wrapper for the %decimal type.
 */
typedef ::xsd::cxx::tree::as_decimal<decimal> as_decimal;

/**
 * @brief Simple type facet.
 */
typedef ::xsd::cxx::tree::facet facet;

// Flags and properties.
//

/**
 * @brief Parsing and serialization flags.
 */
typedef ::xsd::cxx::tree::flags flags;

/**
 * @brief Parsing properties.
 */
typedef ::xsd::cxx::tree::properties<char> properties;

// Parsing/serialization diagnostics.
//

/**
 * @brief Error severity.
 */
typedef ::xsd::cxx::tree::severity severity;

/**
 * @brief Error condition.
 */
typedef ::xsd::cxx::tree::error<char> error;

/**
 * @brief List of %error conditions.
 */
typedef ::xsd::cxx::tree::diagnostics<char> diagnostics;

// Exceptions.
//

/**
 * @brief Root of the C++/Tree %exception hierarchy.
 */
typedef ::xsd::cxx::tree::exception<char> exception;

/**
 * @brief Exception indicating that the size argument exceeds
 * the capacity argument.
 */
typedef ::xsd::cxx::tree::bounds<char> bounds;

/**
 * @brief Exception indicating that a duplicate ID value
 * was encountered in the object model.
 */
typedef ::xsd::cxx::tree::duplicate_id<char> duplicate_id;

/**
 * @brief Exception indicating a parsing failure.
 */
typedef ::xsd::cxx::tree::parsing<char> parsing;

/**
 * @brief Exception indicating that an expected element
 * was not encountered.
 */
typedef ::xsd::cxx::tree::expected_element<char> expected_element;

/**
 * @brief Exception indicating that an unexpected element
 * was encountered.
 */
typedef ::xsd::cxx::tree::unexpected_element<char> unexpected_element;

/**
 * @brief Exception indicating that an expected attribute
 * was not encountered.
 */
typedef ::xsd::cxx::tree::expected_attribute<char> expected_attribute;

/**
 * @brief Exception indicating that an unexpected enumerator
 * was encountered.
 */
typedef ::xsd::cxx::tree::unexpected_enumerator<char> unexpected_enumerator;

/**
 * @brief Exception indicating that the text content was
 * expected for an element.
 */
typedef ::xsd::cxx::tree::expected_text_content<char> expected_text_content;

/**
 * @brief Exception indicating that a prefix-namespace
 * mapping was not provided.
 */
typedef ::xsd::cxx::tree::no_prefix_mapping<char> no_prefix_mapping;

/**
 * @brief Exception indicating a serialization failure.
 */
typedef ::xsd::cxx::tree::serialization<char> serialization;

/**
 * @brief Error handler callback interface.
 */
typedef ::xsd::cxx::xml::error_handler<char> error_handler;

/**
 * @brief DOM interaction.
 */
namespace dom {
/**
 * @brief Automatic pointer for DOMDocument.
 */
using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
/**
 * @brief DOM user data key for back pointers to tree nodes.
 */
const XMLCh *const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
}
}

// Forward declarations.
//
class cuboid_t;
class sphere_t;
class vector_t;
class vector_i;
class input_t;
class boundary_t;
class shape_t;
class directSum_t;
class linkedCell_t;
class strategy_t;
class simulation_t;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief Class corresponding to the %cuboid_t schema type.
 *
 * @nosubgrouping
 */
class cuboid_t : public ::xml_schema::type {
 public:
  /**
   * @name Position
   *
   * @brief Accessor and modifier functions for the %Position
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::vector_t Position_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Position_type, char> Position_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Position_type &Position() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Position_type &Position();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Position(const Position_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void Position(::std::unique_ptr<Position_type> p);

  //@}

  /**
   * @name Velocity
   *
   * @brief Accessor and modifier functions for the %Velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::vector_t Velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Velocity_type, char> Velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Velocity_type &Velocity() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Velocity_type &Velocity();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Velocity(const Velocity_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void Velocity(::std::unique_ptr<Velocity_type> p);

  //@}

  /**
   * @name Dimension
   *
   * @brief Accessor and modifier functions for the %Dimension
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::vector_i Dimension_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Dimension_type, char> Dimension_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Dimension_type &Dimension() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Dimension_type &Dimension();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Dimension(const Dimension_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void Dimension(::std::unique_ptr<Dimension_type> p);

  //@}

  /**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ distance_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<distance_type, char, ::xsd::cxx::tree::schema_type::double_> distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const distance_type &distance() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  distance_type &distance();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void distance(const distance_type &x);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ mass_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<mass_type, char, ::xsd::cxx::tree::schema_type::double_> mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const mass_type &mass() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  mass_type &mass();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void mass(const mass_type &x);

  //@}

  /**
   * @name meanValue
   *
   * @brief Accessor and modifier functions for the %meanValue
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ meanValue_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<meanValue_type, char, ::xsd::cxx::tree::schema_type::double_> meanValue_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const meanValue_type &meanValue() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  meanValue_type &meanValue();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void meanValue(const meanValue_type &x);

  //@}

  /**
   * @name packed
   *
   * @brief Accessor and modifier functions for the %packed
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::boolean packed_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<packed_type, char> packed_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const packed_type &packed() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  packed_type &packed();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void packed(const packed_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  cuboid_t(const Position_type &, const Velocity_type &, const Dimension_type &, const distance_type &,
           const mass_type &, const meanValue_type &, const packed_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  cuboid_t(::std::unique_ptr<Position_type>, ::std::unique_ptr<Velocity_type>, ::std::unique_ptr<Dimension_type>,
           const distance_type &, const mass_type &, const meanValue_type &, const packed_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  cuboid_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  cuboid_t(const cuboid_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual cuboid_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  cuboid_t &operator=(const cuboid_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~cuboid_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<Position_type> Position_;
  ::xsd::cxx::tree::one<Velocity_type> Velocity_;
  ::xsd::cxx::tree::one<Dimension_type> Dimension_;
  ::xsd::cxx::tree::one<distance_type> distance_;
  ::xsd::cxx::tree::one<mass_type> mass_;
  ::xsd::cxx::tree::one<meanValue_type> meanValue_;
  ::xsd::cxx::tree::one<packed_type> packed_;

  //@endcond
};

/**
 * @brief Class corresponding to the %sphere_t schema type.
 *
 * @nosubgrouping
 */
class sphere_t : public ::xml_schema::type {
 public:
  /**
   * @name Center
   *
   * @brief Accessor and modifier functions for the %Center
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::vector_t Center_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Center_type, char> Center_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Center_type &Center() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Center_type &Center();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Center(const Center_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void Center(::std::unique_ptr<Center_type> p);

  //@}

  /**
   * @name Velocity
   *
   * @brief Accessor and modifier functions for the %Velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::vector_t Velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Velocity_type, char> Velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Velocity_type &Velocity() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Velocity_type &Velocity();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Velocity(const Velocity_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void Velocity(::std::unique_ptr<Velocity_type> p);

  //@}

  /**
   * @name radius
   *
   * @brief Accessor and modifier functions for the %radius
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer radius_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<radius_type, char> radius_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const radius_type &radius() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  radius_type &radius();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void radius(const radius_type &x);

  //@}

  /**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ distance_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<distance_type, char, ::xsd::cxx::tree::schema_type::double_> distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const distance_type &distance() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  distance_type &distance();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void distance(const distance_type &x);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ mass_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<mass_type, char, ::xsd::cxx::tree::schema_type::double_> mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const mass_type &mass() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  mass_type &mass();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void mass(const mass_type &x);

  //@}

  /**
   * @name meanValue
   *
   * @brief Accessor and modifier functions for the %meanValue
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ meanValue_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<meanValue_type, char, ::xsd::cxx::tree::schema_type::double_> meanValue_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const meanValue_type &meanValue() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  meanValue_type &meanValue();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void meanValue(const meanValue_type &x);

  //@}

  /**
   * @name packed
   *
   * @brief Accessor and modifier functions for the %packed
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::boolean packed_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<packed_type, char> packed_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const packed_type &packed() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  packed_type &packed();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void packed(const packed_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  sphere_t(const Center_type &, const Velocity_type &, const radius_type &, const distance_type &, const mass_type &,
           const meanValue_type &, const packed_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  sphere_t(::std::unique_ptr<Center_type>, ::std::unique_ptr<Velocity_type>, const radius_type &, const distance_type &,
           const mass_type &, const meanValue_type &, const packed_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  sphere_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  sphere_t(const sphere_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual sphere_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  sphere_t &operator=(const sphere_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~sphere_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<Center_type> Center_;
  ::xsd::cxx::tree::one<Velocity_type> Velocity_;
  ::xsd::cxx::tree::one<radius_type> radius_;
  ::xsd::cxx::tree::one<distance_type> distance_;
  ::xsd::cxx::tree::one<mass_type> mass_;
  ::xsd::cxx::tree::one<meanValue_type> meanValue_;
  ::xsd::cxx::tree::one<packed_type> packed_;

  //@endcond
};

/**
 * @brief Class corresponding to the %vector_t schema type.
 *
 * @nosubgrouping
 */
class vector_t : public ::xml_schema::type {
 public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ x_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<x_type, char, ::xsd::cxx::tree::schema_type::double_> x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const x_type &x() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  x_type &x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void x(const x_type &x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ y_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<y_type, char, ::xsd::cxx::tree::schema_type::double_> y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const y_type &y() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  y_type &y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void y(const y_type &x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ z_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<z_type, char, ::xsd::cxx::tree::schema_type::double_> z_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const z_type &z() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  z_type &z();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void z(const z_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  vector_t(const x_type &, const y_type &, const z_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  vector_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  vector_t(const vector_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual vector_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  vector_t &operator=(const vector_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~vector_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<x_type> x_;
  ::xsd::cxx::tree::one<y_type> y_;
  ::xsd::cxx::tree::one<z_type> z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %vector_i schema type.
 *
 * @nosubgrouping
 */
class vector_i : public ::xml_schema::type {
 public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer x_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<x_type, char> x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const x_type &x() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  x_type &x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void x(const x_type &x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer y_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<y_type, char> y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const y_type &y() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  y_type &y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void y(const y_type &x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer z_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<z_type, char> z_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const z_type &z() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  z_type &z();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void z(const z_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  vector_i(const x_type &, const y_type &, const z_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  vector_i(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  vector_i(const vector_i &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual vector_i *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  vector_i &operator=(const vector_i &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~vector_i();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<x_type> x_;
  ::xsd::cxx::tree::one<y_type> y_;
  ::xsd::cxx::tree::one<z_type> z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %input_t schema type.
 *
 * @nosubgrouping
 */
class input_t : public ::xml_schema::type {
 public:
  /**
   * @name path
   *
   * @brief Accessor and modifier functions for the %path
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string path_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<path_type, char> path_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const path_type &path() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  path_type &path();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void path(const path_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void path(::std::unique_ptr<path_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  input_t(const path_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  input_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  input_t(const input_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual input_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  input_t &operator=(const input_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~input_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<path_type> path_;

  //@endcond
};

/**
 * @brief Class corresponding to the %boundary_t schema type.
 *
 * @nosubgrouping
 */
class boundary_t : public ::xml_schema::type {
 public:
  /**
   * @name boundary
   *
   * @brief Accessor and modifier functions for the %boundary
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string boundary_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<boundary_type> boundary_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<boundary_type, char> boundary_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const boundary_optional &boundary() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  boundary_optional &boundary();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void boundary(const boundary_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void boundary(const boundary_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void boundary(::std::unique_ptr<boundary_type> p);

  //@}

  /**
   * @name boundary-right
   *
   * @brief Accessor and modifier functions for the %boundary-right
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string boundary_right_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<boundary_right_type> boundary_right_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<boundary_right_type, char> boundary_right_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const boundary_right_optional &boundary_right() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  boundary_right_optional &boundary_right();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void boundary_right(const boundary_right_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void boundary_right(const boundary_right_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void boundary_right(::std::unique_ptr<boundary_right_type> p);

  //@}

  /**
   * @name boundary-left
   *
   * @brief Accessor and modifier functions for the %boundary-left
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string boundary_left_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<boundary_left_type> boundary_left_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<boundary_left_type, char> boundary_left_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const boundary_left_optional &boundary_left() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  boundary_left_optional &boundary_left();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void boundary_left(const boundary_left_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void boundary_left(const boundary_left_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void boundary_left(::std::unique_ptr<boundary_left_type> p);

  //@}

  /**
   * @name boundary-top
   *
   * @brief Accessor and modifier functions for the %boundary-top
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string boundary_top_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<boundary_top_type> boundary_top_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<boundary_top_type, char> boundary_top_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const boundary_top_optional &boundary_top() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  boundary_top_optional &boundary_top();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void boundary_top(const boundary_top_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void boundary_top(const boundary_top_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void boundary_top(::std::unique_ptr<boundary_top_type> p);

  //@}

  /**
   * @name boundary-bottom
   *
   * @brief Accessor and modifier functions for the %boundary-bottom
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string boundary_bottom_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<boundary_bottom_type> boundary_bottom_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<boundary_bottom_type, char> boundary_bottom_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const boundary_bottom_optional &boundary_bottom() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  boundary_bottom_optional &boundary_bottom();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void boundary_bottom(const boundary_bottom_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void boundary_bottom(const boundary_bottom_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void boundary_bottom(::std::unique_ptr<boundary_bottom_type> p);

  //@}

  /**
   * @name boundary-back
   *
   * @brief Accessor and modifier functions for the %boundary-back
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string boundary_back_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<boundary_back_type> boundary_back_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<boundary_back_type, char> boundary_back_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const boundary_back_optional &boundary_back() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  boundary_back_optional &boundary_back();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void boundary_back(const boundary_back_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void boundary_back(const boundary_back_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void boundary_back(::std::unique_ptr<boundary_back_type> p);

  //@}

  /**
   * @name boundary-front
   *
   * @brief Accessor and modifier functions for the %boundary-front
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string boundary_front_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<boundary_front_type> boundary_front_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<boundary_front_type, char> boundary_front_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const boundary_front_optional &boundary_front() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  boundary_front_optional &boundary_front();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void boundary_front(const boundary_front_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void boundary_front(const boundary_front_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void boundary_front(::std::unique_ptr<boundary_front_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  boundary_t();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  boundary_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  boundary_t(const boundary_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual boundary_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  boundary_t &operator=(const boundary_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~boundary_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  boundary_optional boundary_;
  boundary_right_optional boundary_right_;
  boundary_left_optional boundary_left_;
  boundary_top_optional boundary_top_;
  boundary_bottom_optional boundary_bottom_;
  boundary_back_optional boundary_back_;
  boundary_front_optional boundary_front_;

  //@endcond
};

/**
 * @brief Class corresponding to the %shape_t schema type.
 *
 * @nosubgrouping
 */
class shape_t : public ::xml_schema::type {
 public:
  /**
   * @name Cuboid
   *
   * @brief Accessor and modifier functions for the %Cuboid
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::cuboid_t Cuboid_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<Cuboid_type> Cuboid_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Cuboid_sequence::iterator Cuboid_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Cuboid_sequence::const_iterator Cuboid_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Cuboid_type, char> Cuboid_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Cuboid_sequence &Cuboid() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Cuboid_sequence &Cuboid();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void Cuboid(const Cuboid_sequence &s);

  //@}

  /**
   * @name Sphere
   *
   * @brief Accessor and modifier functions for the %Sphere
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::sphere_t Sphere_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<Sphere_type> Sphere_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Sphere_sequence::iterator Sphere_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Sphere_sequence::const_iterator Sphere_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Sphere_type, char> Sphere_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Sphere_sequence &Sphere() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Sphere_sequence &Sphere();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void Sphere(const Sphere_sequence &s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  shape_t();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  shape_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  shape_t(const shape_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual shape_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  shape_t &operator=(const shape_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~shape_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  Cuboid_sequence Cuboid_;
  Sphere_sequence Sphere_;

  //@endcond
};

/**
 * @brief Class corresponding to the %directSum_t schema type.
 *
 * @nosubgrouping
 */
class directSum_t : public ::xml_schema::type {
 public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  directSum_t();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  directSum_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  directSum_t(const ::xercesc::DOMAttr &a, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  directSum_t(const ::std::string &s, const ::xercesc::DOMElement *e, ::xml_schema::flags f = 0,
              ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  directSum_t(const directSum_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual directSum_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~directSum_t();
};

/**
 * @brief Class corresponding to the %linkedCell_t schema type.
 *
 * @nosubgrouping
 */
class linkedCell_t : public ::xml_schema::type {
 public:
  /**
   * @name Boundary
   *
   * @brief Accessor and modifier functions for the %Boundary
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::boundary_t Boundary_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Boundary_type, char> Boundary_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Boundary_type &Boundary() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Boundary_type &Boundary();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Boundary(const Boundary_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void Boundary(::std::unique_ptr<Boundary_type> p);

  //@}

  /**
   * @name Domain
   *
   * @brief Accessor and modifier functions for the %Domain
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::vector_i Domain_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Domain_type, char> Domain_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Domain_type &Domain() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Domain_type &Domain();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Domain(const Domain_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void Domain(::std::unique_ptr<Domain_type> p);

  //@}

  /**
   * @name CellSize
   *
   * @brief Accessor and modifier functions for the %CellSize
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::vector_i CellSize_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<CellSize_type, char> CellSize_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const CellSize_type &CellSize() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  CellSize_type &CellSize();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void CellSize(const CellSize_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void CellSize(::std::unique_ptr<CellSize_type> p);

  //@}

  /**
   * @name cutoffRadius
   *
   * @brief Accessor and modifier functions for the %cutoffRadius
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ cutoffRadius_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<cutoffRadius_type, char, ::xsd::cxx::tree::schema_type::double_> cutoffRadius_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const cutoffRadius_type &cutoffRadius() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  cutoffRadius_type &cutoffRadius();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void cutoffRadius(const cutoffRadius_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  linkedCell_t(const Boundary_type &, const Domain_type &, const CellSize_type &, const cutoffRadius_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  linkedCell_t(::std::unique_ptr<Boundary_type>, ::std::unique_ptr<Domain_type>, ::std::unique_ptr<CellSize_type>,
               const cutoffRadius_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  linkedCell_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  linkedCell_t(const linkedCell_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual linkedCell_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  linkedCell_t &operator=(const linkedCell_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~linkedCell_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<Boundary_type> Boundary_;
  ::xsd::cxx::tree::one<Domain_type> Domain_;
  ::xsd::cxx::tree::one<CellSize_type> CellSize_;
  ::xsd::cxx::tree::one<cutoffRadius_type> cutoffRadius_;

  //@endcond
};

/**
 * @brief Class corresponding to the %strategy_t schema type.
 *
 * @nosubgrouping
 */
class strategy_t : public ::xml_schema::type {
 public:
  /**
   * @name LinkedCell
   *
   * @brief Accessor and modifier functions for the %LinkedCell
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::linkedCell_t LinkedCell_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<LinkedCell_type> LinkedCell_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<LinkedCell_type, char> LinkedCell_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const LinkedCell_optional &LinkedCell() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  LinkedCell_optional &LinkedCell();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void LinkedCell(const LinkedCell_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void LinkedCell(const LinkedCell_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void LinkedCell(::std::unique_ptr<LinkedCell_type> p);

  //@}

  /**
   * @name DirectSum
   *
   * @brief Accessor and modifier functions for the %DirectSum
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::directSum_t DirectSum_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<DirectSum_type> DirectSum_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<DirectSum_type, char> DirectSum_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DirectSum_optional &DirectSum() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  DirectSum_optional &DirectSum();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void DirectSum(const DirectSum_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void DirectSum(const DirectSum_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void DirectSum(::std::unique_ptr<DirectSum_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  strategy_t();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  strategy_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  strategy_t(const strategy_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual strategy_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  strategy_t &operator=(const strategy_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~strategy_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  LinkedCell_optional LinkedCell_;
  DirectSum_optional DirectSum_;

  //@endcond
};

/**
 * @brief Class corresponding to the %simulation_t schema type.
 *
 * @nosubgrouping
 */
class simulation_t : public ::xml_schema::type {
 public:
  /**
   * @name Shapes
   *
   * @brief Accessor and modifier functions for the %Shapes
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::shape_t Shapes_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<Shapes_type> Shapes_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Shapes_sequence::iterator Shapes_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Shapes_sequence::const_iterator Shapes_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Shapes_type, char> Shapes_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Shapes_sequence &Shapes() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Shapes_sequence &Shapes();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void Shapes(const Shapes_sequence &s);

  //@}

  /**
   * @name Source
   *
   * @brief Accessor and modifier functions for the %Source
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::input_t Source_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<Source_type> Source_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Source_sequence::iterator Source_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Source_sequence::const_iterator Source_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Source_type, char> Source_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Source_sequence &Source() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Source_sequence &Source();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void Source(const Source_sequence &s);

  //@}

  /**
   * @name Strategy
   *
   * @brief Accessor and modifier functions for the %Strategy
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::strategy_t Strategy_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<Strategy_type> Strategy_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Strategy_type, char> Strategy_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Strategy_optional &Strategy() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Strategy_optional &Strategy();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Strategy(const Strategy_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void Strategy(const Strategy_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void Strategy(::std::unique_ptr<Strategy_type> p);

  //@}

  /**
   * @name endTime
   *
   * @brief Accessor and modifier functions for the %endTime
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ endTime_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<endTime_type, char, ::xsd::cxx::tree::schema_type::double_> endTime_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const endTime_type &endTime() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  endTime_type &endTime();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void endTime(const endTime_type &x);

  //@}

  /**
   * @name deltaT
   *
   * @brief Accessor and modifier functions for the %deltaT
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::double_ deltaT_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<deltaT_type, char, ::xsd::cxx::tree::schema_type::double_> deltaT_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const deltaT_type &deltaT() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  deltaT_type &deltaT();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void deltaT(const deltaT_type &x);

  //@}

  /**
   * @name output
   *
   * @brief Accessor and modifier functions for the %output
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string output_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<output_type, char> output_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const output_type &output() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  output_type &output();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void output(const output_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void output(::std::unique_ptr<output_type> p);

  //@}

  /**
   * @name iteration
   *
   * @brief Accessor and modifier functions for the %iteration
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer iteration_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<iteration_type, char> iteration_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const iteration_type &iteration() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  iteration_type &iteration();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void iteration(const iteration_type &x);

  //@}

  /**
   * @name physics
   *
   * @brief Accessor and modifier functions for the %physics
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string physics_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<physics_type, char> physics_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const physics_type &physics() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  physics_type &physics();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void physics(const physics_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void physics(::std::unique_ptr<physics_type> p);

  //@}

  /**
   * @name writer
   *
   * @brief Accessor and modifier functions for the %writer
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string writer_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<writer_type, char> writer_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const writer_type &writer() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  writer_type &writer();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void writer(const writer_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void writer(::std::unique_ptr<writer_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  simulation_t(const endTime_type &, const deltaT_type &, const output_type &, const iteration_type &,
               const physics_type &, const writer_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  simulation_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  simulation_t(const simulation_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual simulation_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  simulation_t &operator=(const simulation_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~simulation_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  Shapes_sequence Shapes_;
  Source_sequence Source_;
  Strategy_optional Strategy_;
  ::xsd::cxx::tree::one<endTime_type> endTime_;
  ::xsd::cxx::tree::one<deltaT_type> deltaT_;
  ::xsd::cxx::tree::one<output_type> output_;
  ::xsd::cxx::tree::one<iteration_type> iteration_;
  ::xsd::cxx::tree::one<physics_type> physics_;
  ::xsd::cxx::tree::one<writer_type> writer_;

  //@endcond
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %Simulation document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t> Simulation(const ::std::string &uri, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(const ::std::string &uri, ::xml_schema::error_handler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(const ::std::string &uri, ::xercesc::DOMErrorHandler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, ::xml_schema::error_handler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, ::xercesc::DOMErrorHandler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, const ::std::string &id, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, const ::std::string &id,
                                             ::xml_schema::error_handler &eh, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, const ::std::string &id,
                                             ::xercesc::DOMErrorHandler &eh, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t> Simulation(::xercesc::InputSource &is, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::xercesc::InputSource &is, ::xml_schema::error_handler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::xercesc::InputSource &is, ::xercesc::DOMErrorHandler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr<::simulation_t> Simulation(const ::xercesc::DOMDocument &d, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr<::simulation_t> Simulation(::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

//@}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void operator<<(::xercesc::DOMElement &, const cuboid_t &);

void operator<<(::xercesc::DOMElement &, const sphere_t &);

void operator<<(::xercesc::DOMElement &, const vector_t &);

void operator<<(::xercesc::DOMElement &, const vector_i &);

void operator<<(::xercesc::DOMElement &, const input_t &);

void operator<<(::xercesc::DOMElement &, const boundary_t &);

void operator<<(::xercesc::DOMElement &, const shape_t &);

void operator<<(::xercesc::DOMElement &, const directSum_t &);

void operator<<(::xercesc::DOMAttr &, const directSum_t &);

void operator<<(::xml_schema::list_stream &, const directSum_t &);

void operator<<(::xercesc::DOMElement &, const linkedCell_t &);

void operator<<(::xercesc::DOMElement &, const strategy_t &);

void operator<<(::xercesc::DOMElement &, const simulation_t &);

/**
 * @name Serialization functions for the %Simulation document root.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void Simulation(::std::ostream &os, const ::simulation_t &x,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void Simulation(::std::ostream &os, const ::simulation_t &x, ::xml_schema::error_handler &eh,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void Simulation(::std::ostream &os, const ::simulation_t &x, ::xercesc::DOMErrorHandler &eh,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void Simulation(::xercesc::XMLFormatTarget &ft, const ::simulation_t &x,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void Simulation(::xercesc::XMLFormatTarget &ft, const ::simulation_t &x, ::xml_schema::error_handler &eh,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void Simulation(::xercesc::XMLFormatTarget &ft, const ::simulation_t &x, ::xercesc::DOMErrorHandler &eh,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void Simulation(::xercesc::DOMDocument &d, const ::simulation_t &x, ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> Simulation(const ::simulation_t &x,
                                                                 const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                                                                 ::xml_schema::flags f = 0);

//@}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // INPUT_H
