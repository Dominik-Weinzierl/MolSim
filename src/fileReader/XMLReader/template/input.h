// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from input.xsd.
 */

#ifndef INPUT_H
#define INPUT_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema {
// anyType and anySimpleType.
//

/**
 * @brief C++ type corresponding to the anyType XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::type type;

/**
 * @brief C++ type corresponding to the anySimpleType XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::simple_type<char, type> simple_type;

/**
 * @brief Alias for the anyType type.
 */
typedef ::xsd::cxx::tree::type container;


// 8-bit
//

/**
 * @brief C++ type corresponding to the byte XML Schema
 * built-in type.
 */
typedef signed char byte;

/**
 * @brief C++ type corresponding to the unsignedByte XML Schema
 * built-in type.
 */
typedef unsigned char unsigned_byte;


// 16-bit
//

/**
 * @brief C++ type corresponding to the short XML Schema
 * built-in type.
 */
typedef short short_;

/**
 * @brief C++ type corresponding to the unsignedShort XML Schema
 * built-in type.
 */
typedef unsigned short unsigned_short;


// 32-bit
//

/**
 * @brief C++ type corresponding to the int XML Schema
 * built-in type.
 */
typedef int int_;

/**
 * @brief C++ type corresponding to the unsignedInt XML Schema
 * built-in type.
 */
typedef unsigned int unsigned_int;


// 64-bit
//

/**
 * @brief C++ type corresponding to the long XML Schema
 * built-in type.
 */
typedef long long long_;

/**
 * @brief C++ type corresponding to the unsignedLong XML Schema
 * built-in type.
 */
typedef unsigned long long unsigned_long;


// Supposed to be arbitrary-length integral types.
//

/**
 * @brief C++ type corresponding to the integer XML Schema
 * built-in type.
 */
typedef long long integer;

/**
 * @brief C++ type corresponding to the nonPositiveInteger XML Schema
 * built-in type.
 */
typedef long long non_positive_integer;

/**
 * @brief C++ type corresponding to the nonNegativeInteger XML Schema
 * built-in type.
 */
typedef unsigned long long non_negative_integer;

/**
 * @brief C++ type corresponding to the positiveInteger XML Schema
 * built-in type.
 */
typedef unsigned long long positive_integer;

/**
 * @brief C++ type corresponding to the negativeInteger XML Schema
 * built-in type.
 */
typedef long long negative_integer;


// Boolean.
//

/**
 * @brief C++ type corresponding to the boolean XML Schema
 * built-in type.
 */
typedef bool boolean;


// Floating-point types.
//

/**
 * @brief C++ type corresponding to the float XML Schema
 * built-in type.
 */
typedef float float_;

/**
 * @brief C++ type corresponding to the double XML Schema
 * built-in type.
 */
typedef double double_;

/**
 * @brief C++ type corresponding to the decimal XML Schema
 * built-in type.
 */
typedef double decimal;


// String types.
//

/**
 * @brief C++ type corresponding to the string XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::string<char, simple_type> string;

/**
 * @brief C++ type corresponding to the normalizedString XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::normalized_string<char, string> normalized_string;

/**
 * @brief C++ type corresponding to the token XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::token<char, normalized_string> token;

/**
 * @brief C++ type corresponding to the Name XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::name<char, token> name;

/**
 * @brief C++ type corresponding to the NMTOKEN XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::nmtoken<char, token> nmtoken;

/**
 * @brief C++ type corresponding to the NMTOKENS XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::nmtokens<char, simple_type, nmtoken> nmtokens;

/**
 * @brief C++ type corresponding to the NCName XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::ncname<char, name> ncname;

/**
 * @brief C++ type corresponding to the language XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::language<char, token> language;


// ID/IDREF.
//

/**
 * @brief C++ type corresponding to the ID XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::id<char, ncname> id;

/**
 * @brief C++ type corresponding to the IDREF XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::idref<char, ncname, type> idref;

/**
 * @brief C++ type corresponding to the IDREFS XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::idrefs<char, simple_type, idref> idrefs;


// URI.
//

/**
 * @brief C++ type corresponding to the anyURI XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::uri<char, simple_type> uri;


// Qualified name.
//

/**
 * @brief C++ type corresponding to the QName XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::qname<char, simple_type, uri, ncname> qname;


// Binary.
//

/**
 * @brief Binary buffer type.
 */
typedef ::xsd::cxx::tree::buffer<char> buffer;

/**
 * @brief C++ type corresponding to the base64Binary XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::base64_binary<char, simple_type> base64_binary;

/**
 * @brief C++ type corresponding to the hexBinary XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::hex_binary<char, simple_type> hex_binary;


// Date/time.
//

/**
 * @brief Time zone type.
 */
typedef ::xsd::cxx::tree::time_zone time_zone;

/**
 * @brief C++ type corresponding to the date XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::date<char, simple_type> date;

/**
 * @brief C++ type corresponding to the dateTime XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::date_time<char, simple_type> date_time;

/**
 * @brief C++ type corresponding to the duration XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::duration<char, simple_type> duration;

/**
 * @brief C++ type corresponding to the gDay XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gday<char, simple_type> gday;

/**
 * @brief C++ type corresponding to the gMonth XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gmonth<char, simple_type> gmonth;

/**
 * @brief C++ type corresponding to the gMonthDay XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gmonth_day<char, simple_type> gmonth_day;

/**
 * @brief C++ type corresponding to the gYear XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gyear<char, simple_type> gyear;

/**
 * @brief C++ type corresponding to the gYearMonth XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::gyear_month<char, simple_type> gyear_month;

/**
 * @brief C++ type corresponding to the time XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::time<char, simple_type> time;


// Entity.
//

/**
 * @brief C++ type corresponding to the ENTITY XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::entity<char, ncname> entity;

/**
 * @brief C++ type corresponding to the ENTITIES XML Schema
 * built-in type.
 */
typedef ::xsd::cxx::tree::entities<char, simple_type, entity> entities;

/**
 * @brief Content order sequence entry.
 */
typedef ::xsd::cxx::tree::content_order content_order;
// Namespace information and list stream. Used in
// serialization functions.
//
/**
 * @brief Namespace serialization information.
 */
typedef ::xsd::cxx::xml::dom::namespace_info<char> namespace_info;

/**
 * @brief Namespace serialization information map.
 */
typedef ::xsd::cxx::xml::dom::namespace_infomap<char> namespace_infomap;

/**
 * @brief List serialization stream.
 */
typedef ::xsd::cxx::tree::list_stream<char> list_stream;

/**
 * @brief Serialization wrapper for the %double type.
 */
typedef ::xsd::cxx::tree::as_double<double_> as_double;

/**
 * @brief Serialization wrapper for the %decimal type.
 */
typedef ::xsd::cxx::tree::as_decimal<decimal> as_decimal;

/**
 * @brief Simple type facet.
 */
typedef ::xsd::cxx::tree::facet facet;

// Flags and properties.
//

/**
 * @brief Parsing and serialization flags.
 */
typedef ::xsd::cxx::tree::flags flags;

/**
 * @brief Parsing properties.
 */
typedef ::xsd::cxx::tree::properties<char> properties;

// Parsing/serialization diagnostics.
//

/**
 * @brief Error severity.
 */
typedef ::xsd::cxx::tree::severity severity;

/**
 * @brief Error condition.
 */
typedef ::xsd::cxx::tree::error<char> error;

/**
 * @brief List of %error conditions.
 */
typedef ::xsd::cxx::tree::diagnostics<char> diagnostics;

// Exceptions.
//

/**
 * @brief Root of the C++/Tree %exception hierarchy.
 */
typedef ::xsd::cxx::tree::exception<char> exception;

/**
 * @brief Exception indicating that the size argument exceeds
 * the capacity argument.
 */
typedef ::xsd::cxx::tree::bounds<char> bounds;

/**
 * @brief Exception indicating that a duplicate ID value
 * was encountered in the object model.
 */
typedef ::xsd::cxx::tree::duplicate_id<char> duplicate_id;

/**
 * @brief Exception indicating a parsing failure.
 */
typedef ::xsd::cxx::tree::parsing<char> parsing;

/**
 * @brief Exception indicating that an expected element
 * was not encountered.
 */
typedef ::xsd::cxx::tree::expected_element<char> expected_element;

/**
 * @brief Exception indicating that an unexpected element
 * was encountered.
 */
typedef ::xsd::cxx::tree::unexpected_element<char> unexpected_element;

/**
 * @brief Exception indicating that an expected attribute
 * was not encountered.
 */
typedef ::xsd::cxx::tree::expected_attribute<char> expected_attribute;

/**
 * @brief Exception indicating that an unexpected enumerator
 * was encountered.
 */
typedef ::xsd::cxx::tree::unexpected_enumerator<char> unexpected_enumerator;

/**
 * @brief Exception indicating that the text content was
 * expected for an element.
 */
typedef ::xsd::cxx::tree::expected_text_content<char> expected_text_content;

/**
 * @brief Exception indicating that a prefix-namespace
 * mapping was not provided.
 */
typedef ::xsd::cxx::tree::no_prefix_mapping<char> no_prefix_mapping;

/**
 * @brief Exception indicating a serialization failure.
 */
typedef ::xsd::cxx::tree::serialization<char> serialization;

/**
 * @brief Error handler callback interface.
 */
typedef ::xsd::cxx::xml::error_handler<char> error_handler;

/**
 * @brief DOM interaction.
 */
namespace dom {
/**
 * @brief Automatic pointer for DOMDocument.
 */
using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
/**
 * @brief DOM user data key for back pointers to tree nodes.
 */
const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
}
}

// Forward declarations.
//
class cuboid_t;
class vector_t;
class vector_i;
class input_t;
class simulation_t;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief Class corresponding to the %cuboid_t schema type.
 *
 * @nosubgrouping
 */
class cuboid_t : public ::xml_schema::type {
 public:
  /**
   * @name Position
   *
   * @brief Accessor and modifier functions for the %Position
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::vector_t Position_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Position_type, char> Position_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Position_type &Position() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Position_type &Position();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Position(const Position_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void Position(::std::unique_ptr<Position_type> p);

  //@}

  /**
   * @name Velocity
   *
   * @brief Accessor and modifier functions for the %Velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::vector_t Velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Velocity_type, char> Velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Velocity_type &Velocity() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Velocity_type &Velocity();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Velocity(const Velocity_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void Velocity(::std::unique_ptr<Velocity_type> p);

  //@}

  /**
   * @name Dimension
   *
   * @brief Accessor and modifier functions for the %Dimension
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::vector_i Dimension_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Dimension_type, char> Dimension_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Dimension_type &Dimension() const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Dimension_type &Dimension();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Dimension(const Dimension_type &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void Dimension(::std::unique_ptr<Dimension_type> p);

  //@}

  /**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal distance_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<distance_type, char, ::xsd::cxx::tree::schema_type::decimal> distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const distance_type &distance() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  distance_type &distance();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void distance(const distance_type &x);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal mass_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<mass_type, char, ::xsd::cxx::tree::schema_type::decimal> mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const mass_type &mass() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  mass_type &mass();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void mass(const mass_type &x);

  //@}

  /**
   * @name meanValue
   *
   * @brief Accessor and modifier functions for the %meanValue
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal meanValue_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<meanValue_type, char, ::xsd::cxx::tree::schema_type::decimal> meanValue_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const meanValue_type &meanValue() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  meanValue_type &meanValue();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void meanValue(const meanValue_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  cuboid_t(const Position_type &, const Velocity_type &, const Dimension_type &, const distance_type &,
           const mass_type &, const meanValue_type &);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  cuboid_t(::std::unique_ptr<Position_type>, ::std::unique_ptr<Velocity_type>, ::std::unique_ptr<Dimension_type>,
           const distance_type &, const mass_type &, const meanValue_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  cuboid_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  cuboid_t(const cuboid_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual cuboid_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  cuboid_t &operator=(const cuboid_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~cuboid_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<Position_type> Position_;
  ::xsd::cxx::tree::one<Velocity_type> Velocity_;
  ::xsd::cxx::tree::one<Dimension_type> Dimension_;
  ::xsd::cxx::tree::one<distance_type> distance_;
  ::xsd::cxx::tree::one<mass_type> mass_;
  ::xsd::cxx::tree::one<meanValue_type> meanValue_;

  //@endcond
};

/**
 * @brief Class corresponding to the %vector_t schema type.
 *
 * @nosubgrouping
 */
class vector_t : public ::xml_schema::type {
 public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal x_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<x_type, char, ::xsd::cxx::tree::schema_type::decimal> x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const x_type &x() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  x_type &x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void x(const x_type &x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal y_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<y_type, char, ::xsd::cxx::tree::schema_type::decimal> y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const y_type &y() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  y_type &y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void y(const y_type &x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal z_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<z_type, char, ::xsd::cxx::tree::schema_type::decimal> z_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const z_type &z() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  z_type &z();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void z(const z_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  vector_t(const x_type &, const y_type &, const z_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  vector_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  vector_t(const vector_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual vector_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  vector_t &operator=(const vector_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~vector_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<x_type> x_;
  ::xsd::cxx::tree::one<y_type> y_;
  ::xsd::cxx::tree::one<z_type> z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %vector_i schema type.
 *
 * @nosubgrouping
 */
class vector_i : public ::xml_schema::type {
 public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer x_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<x_type, char> x_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const x_type &x() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  x_type &x();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void x(const x_type &x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer y_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<y_type, char> y_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const y_type &y() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  y_type &y();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void y(const y_type &x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer z_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<z_type, char> z_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const z_type &z() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  z_type &z();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void z(const z_type &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  vector_i(const x_type &, const y_type &, const z_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  vector_i(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  vector_i(const vector_i &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual vector_i *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  vector_i &operator=(const vector_i &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~vector_i();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<x_type> x_;
  ::xsd::cxx::tree::one<y_type> y_;
  ::xsd::cxx::tree::one<z_type> z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %input_t schema type.
 *
 * @nosubgrouping
 */
class input_t : public ::xml_schema::type {
 public:
  /**
   * @name location
   *
   * @brief Accessor and modifier functions for the %location
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string location_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<location_type, char> location_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const location_type &location() const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  location_type &location();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void location(const location_type &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void location(::std::unique_ptr<location_type> p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  input_t(const location_type &);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  input_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  input_t(const input_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual input_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  input_t &operator=(const input_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~input_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  ::xsd::cxx::tree::one<location_type> location_;

  //@endcond
};

/**
 * @brief Class corresponding to the %simulation_t schema type.
 *
 * @nosubgrouping
 */
class simulation_t : public ::xml_schema::type {
 public:
  /**
   * @name Cuboid
   *
   * @brief Accessor and modifier functions for the %Cuboid
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::cuboid_t Cuboid_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<Cuboid_type> Cuboid_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Cuboid_sequence::iterator Cuboid_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Cuboid_sequence::const_iterator Cuboid_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Cuboid_type, char> Cuboid_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Cuboid_sequence &Cuboid() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Cuboid_sequence &Cuboid();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void Cuboid(const Cuboid_sequence &s);

  //@}

  /**
   * @name Source
   *
   * @brief Accessor and modifier functions for the %Source
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::input_t Source_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence<Source_type> Source_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Source_sequence::iterator Source_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Source_sequence::const_iterator Source_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Source_type, char> Source_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Source_sequence &Source() const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Source_sequence &Source();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void Source(const Source_sequence &s);

  //@}

  /**
   * @name Physics
   *
   * @brief Accessor and modifier functions for the %Physics
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string Physics_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<Physics_type> Physics_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Physics_type, char> Physics_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Physics_optional &Physics() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Physics_optional &Physics();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Physics(const Physics_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void Physics(const Physics_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void Physics(::std::unique_ptr<Physics_type> p);

  //@}

  /**
   * @name Writer
   *
   * @brief Accessor and modifier functions for the %Writer
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string Writer_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional<Writer_type> Writer_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits<Writer_type, char> Writer_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Writer_optional &Writer() const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Writer_optional &Writer();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void Writer(const Writer_type &x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void Writer(const Writer_optional &x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void Writer(::std::unique_ptr<Writer_type> p);

  //@}

  /**
   * @name endTime
   *
   * @brief Accessor and modifier functions for the %endTime
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal endTime_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<endTime_type> endTime_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<endTime_type, char, ::xsd::cxx::tree::schema_type::decimal> endTime_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const endTime_optional &endTime() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  endTime_optional &endTime();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void endTime(const endTime_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void endTime(const endTime_optional &x);

  //@}

  /**
   * @name deltaT
   *
   * @brief Accessor and modifier functions for the %deltaT
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::decimal deltaT_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<deltaT_type> deltaT_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<deltaT_type, char, ::xsd::cxx::tree::schema_type::decimal> deltaT_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const deltaT_optional &deltaT() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  deltaT_optional &deltaT();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void deltaT(const deltaT_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void deltaT(const deltaT_optional &x);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string name_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<name_type> name_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<name_type, char> name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const name_optional &name() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  name_optional &name();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void name(const name_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void name(const name_optional &x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void name(::std::unique_ptr<name_type> p);

  //@}

  /**
   * @name iteration
   *
   * @brief Accessor and modifier functions for the %iteration
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer iteration_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional<iteration_type> iteration_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits<iteration_type, char> iteration_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const iteration_optional &iteration() const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  iteration_optional &iteration();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void iteration(const iteration_type &x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void iteration(const iteration_optional &x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  simulation_t();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  simulation_t(const ::xercesc::DOMElement &e, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  simulation_t(const simulation_t &x, ::xml_schema::flags f = 0, ::xml_schema::container *c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual simulation_t *_clone(::xml_schema::flags f = 0, ::xml_schema::container *c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  simulation_t &operator=(const simulation_t &x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual
  ~simulation_t();

  // Implementation.
  //

  //@cond

 protected:
  void parse(::xsd::cxx::xml::dom::parser<char> &, ::xml_schema::flags);

 protected:
  Cuboid_sequence Cuboid_;
  Source_sequence Source_;
  Physics_optional Physics_;
  Writer_optional Writer_;
  endTime_optional endTime_;
  deltaT_optional deltaT_;
  name_optional name_;
  iteration_optional iteration_;

  //@endcond
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %Simulation document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t> Simulation(const ::std::string &uri, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(const ::std::string &uri, ::xml_schema::error_handler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(const ::std::string &uri, ::xercesc::DOMErrorHandler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, ::xml_schema::error_handler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, ::xercesc::DOMErrorHandler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, const ::std::string &id, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, const ::std::string &id,
                                             ::xml_schema::error_handler &eh, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::std::istream &is, const ::std::string &id,
                                             ::xercesc::DOMErrorHandler &eh, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr<::simulation_t> Simulation(::xercesc::InputSource &is, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::xercesc::InputSource &is, ::xml_schema::error_handler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr<::simulation_t> Simulation(::xercesc::InputSource &is, ::xercesc::DOMErrorHandler &eh,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr<::simulation_t> Simulation(const ::xercesc::DOMDocument &d, ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr<::simulation_t> Simulation(::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d,
                                             ::xml_schema::flags f = 0,
                                             const ::xml_schema::properties &p = ::xml_schema::properties());

//@}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void operator<<(::xercesc::DOMElement &, const cuboid_t &);

void operator<<(::xercesc::DOMElement &, const vector_t &);

void operator<<(::xercesc::DOMElement &, const vector_i &);

void operator<<(::xercesc::DOMElement &, const input_t &);

void operator<<(::xercesc::DOMElement &, const simulation_t &);

/**
 * @name Serialization functions for the %Simulation document root.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void Simulation(::std::ostream &os, const ::simulation_t &x,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void Simulation(::std::ostream &os, const ::simulation_t &x, ::xml_schema::error_handler &eh,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void Simulation(::std::ostream &os, const ::simulation_t &x, ::xercesc::DOMErrorHandler &eh,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void Simulation(::xercesc::XMLFormatTarget &ft, const ::simulation_t &x,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void Simulation(::xercesc::XMLFormatTarget &ft, const ::simulation_t &x, ::xml_schema::error_handler &eh,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void Simulation(::xercesc::XMLFormatTarget &ft, const ::simulation_t &x, ::xercesc::DOMErrorHandler &eh,
                const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                const ::std::string &e = "UTF-8", ::xml_schema::flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void Simulation(::xercesc::DOMDocument &d, const ::simulation_t &x, ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> Simulation(const ::simulation_t &x,
                                                                 const ::xml_schema::namespace_infomap &m = ::xml_schema::namespace_infomap(),
                                                                 ::xml_schema::flags f = 0);

//@}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // INPUT_H
