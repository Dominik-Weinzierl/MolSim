// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "input.h"

// Cuboid_t
// 

const Cuboid_t::PositionType &Cuboid_t::Position() const {
  return this->Position_.get();
}

Cuboid_t::PositionType &Cuboid_t::Position() {
  return this->Position_.get();
}

void Cuboid_t::Position(const PositionType &x) {
  this->Position_.set(x);
}

void Cuboid_t::Position(::std::unique_ptr<PositionType> x) {
  this->Position_.set(std::move(x));
}

const Cuboid_t::DistanceType &Cuboid_t::distance() const {
  return this->distance_.get();
}

Cuboid_t::DistanceType &Cuboid_t::distance() {
  return this->distance_.get();
}

void Cuboid_t::distance(const DistanceType &x) {
  this->distance_.set(x);
}

const Cuboid_t::MassType &Cuboid_t::mass() const {
  return this->mass_.get();
}

Cuboid_t::MassType &Cuboid_t::mass() {
  return this->mass_.get();
}

void Cuboid_t::mass(const MassType &x) {
  this->mass_.set(x);
}

const Cuboid_t::MeanValueType &Cuboid_t::meanValue() const {
  return this->meanValue_.get();
}

Cuboid_t::MeanValueType &Cuboid_t::meanValue() {
  return this->meanValue_.get();
}

void Cuboid_t::meanValue(const MeanValueType &x) {
  this->meanValue_.set(x);
}


// Vector_t
// 

const Vector_t::XType &Vector_t::x() const {
  return this->x_.get();
}

Vector_t::XType &Vector_t::x() {
  return this->x_.get();
}

void Vector_t::x(const XType &x) {
  this->x_.set(x);
}

const Vector_t::YType &Vector_t::y() const {
  return this->y_.get();
}

Vector_t::YType &Vector_t::y() {
  return this->y_.get();
}

void Vector_t::y(const YType &x) {
  this->y_.set(x);
}

const Vector_t::ZType &Vector_t::z() const {
  return this->z_.get();
}

Vector_t::ZType &Vector_t::z() {
  return this->z_.get();
}

void Vector_t::z(const ZType &x) {
  this->z_.set(x);
}


// Input_t
// 

const Input_t::LocationType &Input_t::location() const {
  return this->location_.get();
}

Input_t::LocationType &Input_t::location() {
  return this->location_.get();
}

void Input_t::location(const LocationType &x) {
  this->location_.set(x);
}

void Input_t::location(::std::unique_ptr<LocationType> x) {
  this->location_.set(std::move(x));
}


// Simulation_t
// 

const Simulation_t::CuboidSequence &Simulation_t::Cuboid() const {
  return this->Cuboid_;
}

Simulation_t::CuboidSequence &Simulation_t::Cuboid() {
  return this->Cuboid_;
}

void Simulation_t::Cuboid(const CuboidSequence &s) {
  this->Cuboid_ = s;
}

const Simulation_t::SourceSequence &Simulation_t::Source() const {
  return this->Source_;
}

Simulation_t::SourceSequence &Simulation_t::Source() {
  return this->Source_;
}

void Simulation_t::Source(const SourceSequence &s) {
  this->Source_ = s;
}

const Simulation_t::EndTimeOptional &Simulation_t::endTime() const {
  return this->endTime_;
}

Simulation_t::EndTimeOptional &Simulation_t::endTime() {
  return this->endTime_;
}

void Simulation_t::endTime(const EndTimeType &x) {
  this->endTime_.set(x);
}

void Simulation_t::endTime(const EndTimeOptional &x) {
  this->endTime_ = x;
}

const Simulation_t::DeltaTOptional &Simulation_t::deltaT() const {
  return this->deltaT_;
}

Simulation_t::DeltaTOptional &Simulation_t::deltaT() {
  return this->deltaT_;
}

void Simulation_t::deltaT(const DeltaTType &x) {
  this->deltaT_.set(x);
}

void Simulation_t::deltaT(const DeltaTOptional &x) {
  this->deltaT_ = x;
}

const Simulation_t::NameOptional &Simulation_t::name() const {
  return this->name_;
}

Simulation_t::NameOptional &Simulation_t::name() {
  return this->name_;
}

void Simulation_t::name(const NameType &x) {
  this->name_.set(x);
}

void Simulation_t::name(const NameOptional &x) {
  this->name_ = x;
}

void Simulation_t::name(::std::unique_ptr<NameType> x) {
  this->name_.set(std::move(x));
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

// Cuboid_t
//

Cuboid_t::Cuboid_t(const PositionType &Position, const DistanceType &distance, const MassType &mass,
                   const MeanValueType &meanValue)
    : ::xml_schema::Type(), Position_(Position, this), distance_(distance, this), mass_(mass, this),
      meanValue_(meanValue, this) {
}

Cuboid_t::Cuboid_t(::std::unique_ptr<PositionType> Position, const DistanceType &distance, const MassType &mass,
                   const MeanValueType &meanValue)
    : ::xml_schema::Type(), Position_(std::move(Position), this), distance_(distance, this), mass_(mass, this),
      meanValue_(meanValue, this) {
}

Cuboid_t::Cuboid_t(const Cuboid_t &x, ::xml_schema::Flags f, ::xml_schema::Container *c) : ::xml_schema::Type(x, f, c),
                                                                                           Position_(x.Position_, f,
                                                                                                     this),
                                                                                           distance_(x.distance_, f,
                                                                                                     this),
                                                                                           mass_(x.mass_, f, this),
                                                                                           meanValue_(x.meanValue_, f,
                                                                                                      this) {
}

Cuboid_t::Cuboid_t(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), Position_(this), distance_(this), mass_(this),
      meanValue_(this) {
  if ((f & ::xml_schema::Flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void Cuboid_t::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // Position
    //
    if (n.name() == "Position" && n.namespace_().empty()) {
      ::std::unique_ptr<PositionType> r(PositionTraits::create(i, f, this));

      if (!Position_.present()) {
        this->Position_.set(::std::move(r));
        continue;
      }
    }

    break;
  }

  if (!Position_.present()) {
    throw ::xsd::cxx::tree::expected_element<char>("Position", "");
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "distance" && n.namespace_().empty()) {
      this->distance_.set(DistanceTraits::create(i, f, this));
      continue;
    }

    if (n.name() == "mass" && n.namespace_().empty()) {
      this->mass_.set(MassTraits::create(i, f, this));
      continue;
    }

    if (n.name() == "meanValue" && n.namespace_().empty()) {
      this->meanValue_.set(MeanValueTraits::create(i, f, this));
      continue;
    }
  }

  if (!distance_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("distance", "");
  }

  if (!mass_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("mass", "");
  }

  if (!meanValue_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("meanValue", "");
  }
}

Cuboid_t *Cuboid_t::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
  return new class Cuboid_t(*this, f, c);
}

Cuboid_t &Cuboid_t::operator=(const Cuboid_t &x) {
  if (this != &x) {
    static_cast< ::xml_schema::Type & > (*this) = x;
    this->Position_ = x.Position_;
    this->distance_ = x.distance_;
    this->mass_ = x.mass_;
    this->meanValue_ = x.meanValue_;
  }

  return *this;
}

Cuboid_t::~Cuboid_t() {
}

// Vector_t
//

Vector_t::Vector_t(const XType &x, const YType &y, const ZType &z)
    : ::xml_schema::Type(), x_(x, this), y_(y, this), z_(z, this) {
}

Vector_t::Vector_t(const Vector_t &x, ::xml_schema::Flags f, ::xml_schema::Container *c) : ::xml_schema::Type(x, f, c),
                                                                                           x_(x.x_, f, this),
                                                                                           y_(x.y_, f, this),
                                                                                           z_(x.z_, f, this) {
}

Vector_t::Vector_t(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), x_(this), y_(this), z_(this) {
  if ((f & ::xml_schema::Flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void Vector_t::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "x" && n.namespace_().empty()) {
      this->x_.set(XTraits::create(i, f, this));
      continue;
    }

    if (n.name() == "y" && n.namespace_().empty()) {
      this->y_.set(YTraits::create(i, f, this));
      continue;
    }

    if (n.name() == "z" && n.namespace_().empty()) {
      this->z_.set(ZTraits::create(i, f, this));
      continue;
    }
  }

  if (!x_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("x", "");
  }

  if (!y_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("y", "");
  }

  if (!z_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("z", "");
  }
}

Vector_t *Vector_t::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
  return new class Vector_t(*this, f, c);
}

Vector_t &Vector_t::operator=(const Vector_t &x) {
  if (this != &x) {
    static_cast< ::xml_schema::Type & > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

Vector_t::~Vector_t() {
}

// Input_t
//

Input_t::Input_t(const LocationType &location) : ::xml_schema::Type(), location_(location, this) {
}

Input_t::Input_t(const Input_t &x, ::xml_schema::Flags f, ::xml_schema::Container *c) : ::xml_schema::Type(x, f, c),
                                                                                        location_(x.location_, f,
                                                                                                  this) {
}

Input_t::Input_t(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), location_(this) {
  if ((f & ::xml_schema::Flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, false, false, true);
    this->parse(p, f);
  }
}

void Input_t::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "location" && n.namespace_().empty()) {
      this->location_.set(LocationTraits::create(i, f, this));
      continue;
    }
  }

  if (!location_.present()) {
    throw ::xsd::cxx::tree::expected_attribute<char>("location", "");
  }
}

Input_t *Input_t::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
  return new class Input_t(*this, f, c);
}

Input_t &Input_t::operator=(const Input_t &x) {
  if (this != &x) {
    static_cast< ::xml_schema::Type & > (*this) = x;
    this->location_ = x.location_;
  }

  return *this;
}

Input_t::~Input_t() {
}

// Simulation_t
//

Simulation_t::Simulation_t()
    : ::xml_schema::Type(), Cuboid_(this), Source_(this), endTime_(this), deltaT_(this), name_(this) {
}

Simulation_t::Simulation_t(const Simulation_t &x, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(x, f, c), Cuboid_(x.Cuboid_, f, this), Source_(x.Source_, f, this),
      endTime_(x.endTime_, f, this), deltaT_(x.deltaT_, f, this), name_(x.name_, f, this) {
}

Simulation_t::Simulation_t(const ::xercesc::DOMElement &e, ::xml_schema::Flags f, ::xml_schema::Container *c)
    : ::xml_schema::Type(e, f | ::xml_schema::Flags::base, c), Cuboid_(this), Source_(this), endTime_(this),
      deltaT_(this), name_(this) {
  if ((f & ::xml_schema::Flags::base) == 0) {
    ::xsd::cxx::xml::dom::parser<char> p(e, true, false, true);
    this->parse(p, f);
  }
}

void Simulation_t::parse(::xsd::cxx::xml::dom::parser<char> &p, ::xml_schema::Flags f) {
  for (; p.more_content(); p.next_content(false)) {
    const ::xercesc::DOMElement &i(p.cur_element());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    // Cuboid
    //
    if (n.name() == "Cuboid" && n.namespace_().empty()) {
      ::std::unique_ptr<CuboidType> r(CuboidTraits::create(i, f, this));

      this->Cuboid_.push_back(::std::move(r));
      continue;
    }

    // Source
    //
    if (n.name() == "Source" && n.namespace_().empty()) {
      ::std::unique_ptr<SourceType> r(SourceTraits::create(i, f, this));

      this->Source_.push_back(::std::move(r));
      continue;
    }

    break;
  }

  while (p.more_attributes()) {
    const ::xercesc::DOMAttr &i(p.next_attribute());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

    if (n.name() == "endTime" && n.namespace_().empty()) {
      this->endTime_.set(EndTimeTraits::create(i, f, this));
      continue;
    }

    if (n.name() == "deltaT" && n.namespace_().empty()) {
      this->deltaT_.set(DeltaTTraits::create(i, f, this));
      continue;
    }

    if (n.name() == "name" && n.namespace_().empty()) {
      this->name_.set(NameTraits::create(i, f, this));
      continue;
    }
  }
}

Simulation_t *Simulation_t::_clone(::xml_schema::Flags f, ::xml_schema::Container *c) const {
  return new class Simulation_t(*this, f, c);
}

Simulation_t &Simulation_t::operator=(const Simulation_t &x) {
  if (this != &x) {
    static_cast< ::xml_schema::Type & > (*this) = x;
    this->Cuboid_ = x.Cuboid_;
    this->Source_ = x.Source_;
    this->endTime_ = x.endTime_;
    this->deltaT_ = x.deltaT_;
    this->name_ = x.name_;
  }

  return *this;
}

Simulation_t::~Simulation_t() {
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr<::Simulation_t> Simulation(const ::std::string &u, ::xml_schema::Flags f,
                                             const ::xml_schema::Properties &p) {
  ::xsd::cxx::xml::auto_initializer
      i((f & ::xml_schema::Flags::dont_initialize) == 0, (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  h.throw_if_failed<::xsd::cxx::tree::parsing<char> >();

  return ::std::unique_ptr<::Simulation_t>(::Simulation(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::Simulation_t> Simulation(const ::std::string &u, ::xml_schema::ErrorHandler &h,
                                             ::xml_schema::Flags f, const ::xml_schema::Properties &p) {
  ::xsd::cxx::xml::auto_initializer
      i((f & ::xml_schema::Flags::dont_initialize) == 0, (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get())
    throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::Simulation_t>(::Simulation(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::Simulation_t> Simulation(const ::std::string &u, ::xercesc::DOMErrorHandler &h,
                                             ::xml_schema::Flags f, const ::xml_schema::Properties &p) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

  if (!d.get())
    throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::Simulation_t>(::Simulation(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::Simulation_t> Simulation(::std::istream &is, ::xml_schema::Flags f,
                                             const ::xml_schema::Properties &p) {
  ::xsd::cxx::xml::auto_initializer
      i((f & ::xml_schema::Flags::dont_initialize) == 0, (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::Simulation(isrc, f, p);
}

::std::unique_ptr<::Simulation_t> Simulation(::std::istream &is, ::xml_schema::ErrorHandler &h, ::xml_schema::Flags f,
                                             const ::xml_schema::Properties &p) {
  ::xsd::cxx::xml::auto_initializer
      i((f & ::xml_schema::Flags::dont_initialize) == 0, (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::Simulation(isrc, h, f, p);
}

::std::unique_ptr<::Simulation_t> Simulation(::std::istream &is, ::xercesc::DOMErrorHandler &h, ::xml_schema::Flags f,
                                             const ::xml_schema::Properties &p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is);
  return ::Simulation(isrc, h, f, p);
}

::std::unique_ptr<::Simulation_t> Simulation(::std::istream &is, const ::std::string &sid, ::xml_schema::Flags f,
                                             const ::xml_schema::Properties &p) {
  ::xsd::cxx::xml::auto_initializer
      i((f & ::xml_schema::Flags::dont_initialize) == 0, (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::Simulation(isrc, f, p);
}

::std::unique_ptr<::Simulation_t> Simulation(::std::istream &is, const ::std::string &sid,
                                             ::xml_schema::ErrorHandler &h, ::xml_schema::Flags f,
                                             const ::xml_schema::Properties &p) {
  ::xsd::cxx::xml::auto_initializer
      i((f & ::xml_schema::Flags::dont_initialize) == 0, (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::Simulation(isrc, h, f, p);
}

::std::unique_ptr<::Simulation_t> Simulation(::std::istream &is, const ::std::string &sid,
                                             ::xercesc::DOMErrorHandler &h, ::xml_schema::Flags f,
                                             const ::xml_schema::Properties &p) {
  ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
  return ::Simulation(isrc, h, f, p);
}

::std::unique_ptr<::Simulation_t> Simulation(::xercesc::InputSource &i, ::xml_schema::Flags f,
                                             const ::xml_schema::Properties &p) {
  ::xsd::cxx::tree::error_handler<char> h;

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  h.throw_if_failed<::xsd::cxx::tree::parsing<char> >();

  return ::std::unique_ptr<::Simulation_t>(::Simulation(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::Simulation_t> Simulation(::xercesc::InputSource &i, ::xml_schema::ErrorHandler &h,
                                             ::xml_schema::Flags f, const ::xml_schema::Properties &p) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get())
    throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::Simulation_t>(::Simulation(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::Simulation_t> Simulation(::xercesc::InputSource &i, ::xercesc::DOMErrorHandler &h,
                                             ::xml_schema::Flags f, const ::xml_schema::Properties &p) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

  if (!d.get())
    throw ::xsd::cxx::tree::parsing<char>();

  return ::std::unique_ptr<::Simulation_t>(::Simulation(std::move(d), f | ::xml_schema::Flags::own_dom, p));
}

::std::unique_ptr<::Simulation_t> Simulation(const ::xercesc::DOMDocument &doc, ::xml_schema::Flags f,
                                             const ::xml_schema::Properties &p) {
  if (f & ::xml_schema::Flags::keep_dom) {
    ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument>
        d(static_cast< ::xercesc::DOMDocument * > (doc.cloneNode(true)));

    return ::std::unique_ptr<::Simulation_t>(::Simulation(std::move(d), f | ::xml_schema::Flags::own_dom, p));
  }

  const ::xercesc::DOMElement &e(*doc.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "Simulation" && n.namespace_() == "") {
    ::std::unique_ptr<::Simulation_t> r(::xsd::cxx::tree::traits<::Simulation_t, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "Simulation", "");
}

::std::unique_ptr<::Simulation_t> Simulation(::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d,
                                             ::xml_schema::Flags f, const ::xml_schema::Properties &) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> c
      (((f & ::xml_schema::Flags::keep_dom) && !(f & ::xml_schema::Flags::own_dom))
       ? static_cast< ::xercesc::DOMDocument * > (d->cloneNode(true)) : 0);

  ::xercesc::DOMDocument &doc(c.get() ? *c : *d);
  const ::xercesc::DOMElement &e(*doc.getDocumentElement());

  const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

  if (f & ::xml_schema::Flags::keep_dom)
    doc.setUserData(::xml_schema::dom::tree_node_key, (c.get() ? &c : &d), 0);

  if (n.name() == "Simulation" && n.namespace_() == "") {
    ::std::unique_ptr<::Simulation_t> r(::xsd::cxx::tree::traits<::Simulation_t, char>::create(e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "Simulation", "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void operator<<(::xercesc::DOMElement &e, const Cuboid_t &i) {
  e << static_cast< const ::xml_schema::Type & > (i);

  // Position
  //
  {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("Position", e));

    s << i.Position();
  }

  // distance
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("distance", e));

    a << ::xml_schema::AsDecimal(i.distance());
  }

  // mass
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("mass", e));

    a << ::xml_schema::AsDecimal(i.mass());
  }

  // meanValue
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("meanValue", e));

    a << ::xml_schema::AsDecimal(i.meanValue());
  }
}

void operator<<(::xercesc::DOMElement &e, const Vector_t &i) {
  e << static_cast< const ::xml_schema::Type & > (i);

  // x
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("x", e));

    a << ::xml_schema::AsDecimal(i.x());
  }

  // y
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("y", e));

    a << ::xml_schema::AsDecimal(i.y());
  }

  // z
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("z", e));

    a << ::xml_schema::AsDecimal(i.z());
  }
}

void operator<<(::xercesc::DOMElement &e, const Input_t &i) {
  e << static_cast< const ::xml_schema::Type & > (i);

  // location
  //
  {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("location", e));

    a << i.location();
  }
}

void operator<<(::xercesc::DOMElement &e, const Simulation_t &i) {
  e << static_cast< const ::xml_schema::Type & > (i);

  // Cuboid
  //
  for (Simulation_t::CuboidConstIterator b(i.Cuboid().begin()), n(i.Cuboid().end()); b != n; ++b) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("Cuboid", e));

    s << *b;
  }

  // Source
  //
  for (Simulation_t::SourceConstIterator b(i.Source().begin()), n(i.Source().end()); b != n; ++b) {
    ::xercesc::DOMElement &s(::xsd::cxx::xml::dom::create_element("Source", e));

    s << *b;
  }

  // endTime
  //
  if (i.endTime()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("endTime", e));

    a << ::xml_schema::AsDecimal(*i.endTime());
  }

  // deltaT
  //
  if (i.deltaT()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("deltaT", e));

    a << ::xml_schema::AsDecimal(*i.deltaT());
  }

  // name
  //
  if (i.name()) {
    ::xercesc::DOMAttr &a(::xsd::cxx::xml::dom::create_attribute("name", e));

    a << *i.name();
  }
}

void Simulation(::std::ostream &o, const ::Simulation_t &s, const ::xml_schema::NamespaceInfomap &m,
                const ::std::string &e, ::xml_schema::Flags f) {
  ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::Flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::Simulation(s, m, f));

  ::xsd::cxx::tree::error_handler<char> h;

  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    h.throw_if_failed<::xsd::cxx::tree::serialization<char> >();
  }
}

void Simulation(::std::ostream &o, const ::Simulation_t &s, ::xml_schema::ErrorHandler &h,
                const ::xml_schema::NamespaceInfomap &m, const ::std::string &e, ::xml_schema::Flags f) {
  ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::Flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::Simulation(s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void Simulation(::std::ostream &o, const ::Simulation_t &s, ::xercesc::DOMErrorHandler &h,
                const ::xml_schema::NamespaceInfomap &m, const ::std::string &e, ::xml_schema::Flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::Simulation(s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t(o);
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void Simulation(::xercesc::XMLFormatTarget &t, const ::Simulation_t &s, const ::xml_schema::NamespaceInfomap &m,
                const ::std::string &e, ::xml_schema::Flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::Simulation(s, m, f));

  ::xsd::cxx::tree::error_handler<char> h;

  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    h.throw_if_failed<::xsd::cxx::tree::serialization<char> >();
  }
}

void Simulation(::xercesc::XMLFormatTarget &t, const ::Simulation_t &s, ::xml_schema::ErrorHandler &h,
                const ::xml_schema::NamespaceInfomap &m, const ::std::string &e, ::xml_schema::Flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::Simulation(s, m, f));
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void Simulation(::xercesc::XMLFormatTarget &t, const ::Simulation_t &s, ::xercesc::DOMErrorHandler &h,
                const ::xml_schema::NamespaceInfomap &m, const ::std::string &e, ::xml_schema::Flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> d(::Simulation(s, m, f));
  if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
    throw ::xsd::cxx::tree::serialization<char>();
  }
}

void Simulation(::xercesc::DOMDocument &d, const ::Simulation_t &s, ::xml_schema::Flags) {
  ::xercesc::DOMElement &e(*d.getDocumentElement());
  const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

  if (n.name() == "Simulation" && n.namespace_() == "") {
    e << s;
  } else {
    throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "Simulation", "");
  }
}

::xml_schema::dom::unique_ptr<::xercesc::DOMDocument> Simulation(const ::Simulation_t &s,
                                                                 const ::xml_schema::NamespaceInfomap &m,
                                                                 ::xml_schema::Flags f) {
  ::xml_schema::dom::unique_ptr<::xercesc::DOMDocument>
      d(::xsd::cxx::xml::dom::serialize<char>("Simulation", "", m, f));

  ::Simulation(*d, s, f);
  return d;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

