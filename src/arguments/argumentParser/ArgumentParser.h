#pragma once

#include <memory>
#include "arguments/argument/Argument.h"
#include <tuple>
#include <unordered_map>
#include <variant>

class ArgumentStatus {
 protected:
  std::unordered_map<std::string, std::tuple<bool, std::string, std::variant<std::string, int, double>>> flags;

 public:
  ArgumentStatus() {
    flags.insert({"filename", {false, "", ""}});
  }
  /**
   * Destructor generated by the compiler.
   */
  virtual ~ArgumentStatus() = default;
  bool validStatus() {
    return std::all_of(flags.begin(), flags.end(), [](auto v) {
      return std::get<0>(std::get<1>(v));
    });
  }

  void updateFlag(const std::string &name, const std::string &flag, std::variant<std::string, int, double> value) {
    std::get<0>(flags[name]) = true;
    std::get<1>(flags[name]) = flag;
    std::get<2>(flags[name]) = std::move(value);
  }

  std::variant<std::string, int, double> getValue(const std::string &name) {
    return std::get<2>(flags[name]);
  }
};

/**
 * ArgumentParser is an extendable parser for arguments via commandline or configuration file.
 */
template<size_t dim>
class ArgumentParser {
 protected:
  /**
   * Tokens is a Vector of Strings generated by the provided arguments
   */
  std::vector<std::string> tokens;
 public:
  /**
   * BasicArgumentsParser is a constructor that takes arguments provided by the main-method.
   * @param argc
   * @param arguments
   */
  explicit ArgumentParser(int argc, char *arguments[]) {
    for (int i = 1; i < argc; ++i) {
      tokens.emplace_back(arguments[i]);
    }
  }

  /**
   * Destructor generated by the compiler.
   */
  virtual ~ArgumentParser() = default;

  /**
   * Creates an Argument via the getValueOfArgumentOption-Method.
   * @return Argument.
   */
  virtual std::unique_ptr<Argument<dim>> createArgument() = 0;

  /**
   * Validates the arguments
   * @return bool
   */
  virtual bool validateInput() = 0;

  /**
   * Prints the available flag-options.
   */
  virtual void showUsage() = 0;

  /**
   * Handle the flags and sets the status accordingly without any additional check
   */
  static void handleFlag(ArgumentStatus &status, const std::string &name, const std::string &flag,
                         const std::string &possibleValue) {
    status.updateFlag(name, flag, possibleValue);
  }

  /**
   * Handle the flags and sets the status accordingly with additional check
   */
  template<typename T>
  void handleFlag(ArgumentStatus &status, const std::string &name, const std::string &flag,
                  const std::string &possibleValue) {
    performCheck<T>(status, name, flag, possibleValue);
  }

  /**
   * Handle the flags and sets the status accordingly with additional value check
   */
  static void handleFlag(ArgumentStatus &status, const std::string &name, const std::string &flag,
                         const std::string &possibleValue, std::vector<std::string> possibleValues) {
    if (std::find(possibleValues.begin(), possibleValues.end(), possibleValue) == possibleValues.end()) {
      throw std::invalid_argument("Expected: " + ArrayUtils::to_string(possibleValues) + " | Got: " + possibleValue);
    }
    status.updateFlag(name, flag, possibleValue);
  }

  /**
   * Handle the flags and sets the status accordingly with additional check
   */
  template<typename T>
  void performCheck(ArgumentStatus &status, const std::string &name, const std::string &flag,
                    const std::string &possibleValue);

};

template<>
template<>
void ArgumentParser<3>::performCheck<int>(ArgumentStatus &status, const std::string &name, const std::string &flag,
                                          const std::string &possibleValue) {
  try {
    status.updateFlag(name, flag, std::stoi(possibleValue));
  } catch (std::invalid_argument &e) {
    throw std::invalid_argument("Expected: int  | Got: " + possibleValue);
  }
}

template<>
template<>
void ArgumentParser<2>::performCheck<int>(ArgumentStatus &status, const std::string &name, const std::string &flag,
                                          const std::string &possibleValue) {
  try {
    status.updateFlag(name, flag, std::stoi(possibleValue));
  } catch (std::invalid_argument &e) {
    throw std::invalid_argument("Expected: int  | Got: " + possibleValue);
  }
}

template<>
template<>
void ArgumentParser<2>::performCheck<double>(ArgumentStatus &status, const std::string &name, const std::string &flag,
                                             const std::string &possibleValue) {
  try {
    status.updateFlag(name, flag, std::stod(possibleValue));
  } catch (std::invalid_argument &e) {
    throw std::invalid_argument("Expected: double  | Got: " + possibleValue);
  }
}

template<>
template<>
void ArgumentParser<3>::performCheck<double>(ArgumentStatus &status, const std::string &name, const std::string &flag,
                                             const std::string &possibleValue) {
  try {
    status.updateFlag(name, flag, std::stod(possibleValue));
  } catch (std::invalid_argument &e) {
    throw std::invalid_argument("Expected: double  | Got: " + possibleValue);
  }
}
