#pragma once

#include <generator/GeneratorArguments/CuboidArgument.h>
#include <arguments/argument/Argument.h>
#include <generator/GeneratorArguments/SphereArgument.h>

#include <iostream>

/**
 * XMLArgument stores the arguments parsed by XMLArgumentParser for easy access.
 * @tparam dim dimension of our simulation.
 */
template<size_t dim>
class XMLArgument : public Argument<dim> {
 private:
  /**
   * Stores the CuboidArgument(s) used by our Generator to create Cuboid(s).
   */
  std::vector<CuboidArgument<dim>> cuboidArguments;

  /**
   * Stores the SphereArgument(s) used by our Generator to create Sphere(s).
   */
  std::vector<SphereArgument<dim>> sphereArguments;

 public:
  /**
   * XMLArgument constructor to construct Arguments provided by the ArgumentParser (XMLArgumentParser).
   * @param pCuboidArguments arguments used to create Cuboids
   * @param pSphereArguments arguments used to create Spheres
   * @param pFiles additional input files to load additional Particle
   * @param pEndTime end time of the simulation
   * @param pDeltaT time steps during the simulation
   * @param pOutput output file prefix
   * @param pWriter used writer to write in the output files
   * @param pIteration defines the writing iteration
   * @param pPhysics defines the used Physics during the simulation
   */
  XMLArgument(std::vector<CuboidArgument<dim>> pCuboidArguments, std::vector<SphereArgument<dim>> pSphereArguments,
              std::vector<std::string> pFiles, double pEndTime, double pDeltaT, std::string pOutput,
              std::string pWriter, int pIteration, std::string pPhysics) : Argument<dim>(std::move(pFiles), pEndTime,
                                                                                         pDeltaT, std::move(pOutput),
                                                                                         std::move(pWriter), pIteration,
                                                                                         std::move(pPhysics)),
                                                                           cuboidArguments{std::move(pCuboidArguments)},
                                                                           sphereArguments{
                                                                               std::move(pSphereArguments)} {

  }

  /**
   * Getter for CuboidArguments.
   * @return std::vector of CuboidArguments.
   */
  [[nodiscard]] const std::vector<CuboidArgument<dim>> &getCuboidArguments() const {
    return cuboidArguments;
  }

  /**
   * Getter for SphereArguments.
   * @return std::vector of SphereArguments.
   */
  [[nodiscard]] const std::vector<SphereArgument<dim>> &getSphereArguments() const {
    return sphereArguments;
  }

  /**
   * Via xml it is possible to define arguments for additional particle generators.
   * @param container the ParticleContainer filled with Particle generated by Generator(s)
   */
  void createAdditionalParticle(ParticleContainer<dim> &container) const override {
    // CuboidGenerator
    for (const auto &cuboidArgument: getCuboidArguments()) {
      Generator<CuboidArgument<dim>, dim>::generate(cuboidArgument, container);
    }

    // SphereGenerator
    for (const auto &sphereArgument: getSphereArguments()) {
      Generator<SphereArgument<dim>, dim>::generate(sphereArgument, container);
    }
  }

  /**
   * Prints the arguments.
   */
  void toString() const override {
    std::stringstream configuration;
    configuration << "\tAdditional input files:" << std::endl;
    for (const auto &f: this->files) {
      configuration << "\t\t" << f << std::endl;
    }
    configuration << "\tEnd time: " << this->endTime << std::endl;;
    configuration << "\tDelta t: " << this->deltaT << std::endl;
    configuration << "\tOutput file prefix: " << this->output << std::endl;
    configuration << "\tFile writer: " << this->writer << std::endl;
    configuration << "\tIteration: " << this->iteration << std::endl;
    configuration << "\tPhysic: " << this->physics << std::endl;
    configuration << "\tAdditional generator:" << std::endl;
    configuration << "\t\tCuboid generator:" << std::endl;
    if (!this->cuboidArguments.empty()) {
      for (const auto &g: this->cuboidArguments) {
        configuration << "\t\t\tCuboid:" << std::endl;
        configuration << "\t\t\t\t Stating coordinates: x: " << g.startingCoordinates[0] << " y: "
                      << g.startingCoordinates[1] << " z: " << g.startingCoordinates[2] << std::endl;
        configuration << "\t\t\t\t Dimension: x: " << g.dimensions[0] << " y: " << g.dimensions[1] << " z: "
                      << g.dimensions[2] << std::endl;
        configuration << "\t\t\t\t Velocity: x: " << g.initialVelocity[0] << " y: " << g.initialVelocity[1] << " z: "
                      << g.initialVelocity[2] << std::endl;
        configuration << "\t\t\t\t Distance: " << g.distance << std::endl;
        configuration << "\t\t\t\t Mass: " << g.mass << std::endl;
        configuration << "\t\t\t\t Mean value: " << g.meanValue << std::endl;
      }
    }
    if (!this->sphereArguments.empty()) {
      configuration << "\t\tSphere generator:" << std::endl;
      for (const auto &s: this->sphereArguments) {
        configuration << "\t\t\tSpheres:" << std::endl;
        configuration << "\t\t\t\t Center coordinates: x: " << s.centerCoordinates[0] << " y: "
                      << s.centerCoordinates[1] << " z: " << s.centerCoordinates[2] << std::endl;
        configuration << "\t\t\t\t Velocity: x: " << s.initialVelocity[0] << " y: " << s.initialVelocity[1] << " z: "
                      << s.initialVelocity[2] << std::endl;
        configuration << "\t\t\t\t Radius: " << s.radius << std::endl;
        configuration << "\t\t\t\t Distance: " << s.distance << std::endl;
        configuration << "\t\t\t\t Mass: " << s.mass << std::endl;
        configuration << "\t\t\t\t Mean value: " << s.meanValue << std::endl;
      }
    }

    std::cout << configuration.str() << std::endl;
  }
};